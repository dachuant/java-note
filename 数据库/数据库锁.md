

### 数据库锁

![](https://gitee.com/dachuant/image/raw/master/picgo/1.png)

#### 表锁和行锁
- InnoDB行锁和表锁都支持
	- 只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁 	
- MyISAM只支持表锁
##### 表锁

- 开销小、加锁快
- 不会出现死锁
- 锁定力度大，发生锁冲突概率高，并发度最低
###### 表读锁（Table Read Lock）
###### 表写锁（Table Write Lock）
- 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁

- 读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁！

- 写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁！

  

  读锁和写锁是互斥的，读写操作是串行

- 如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在mysql里边，写锁是优先于读锁的！

- 写锁和读锁优先级的问题是可以通过参数调节的：`max_write_lock_count`和`low-priority-updates`

##### 行锁

- 开销大，加锁慢
- 会出现死锁
- 锁定粒度小，发生锁冲突的概率低，并发度高

###### InnoDB 行锁
- 共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
	也叫做读锁：读锁是共享的，多个客户可以同时读取同一个资源，但不允许其他客户修改。
	
- 排他锁（X锁)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
	也叫做写锁：写锁是排他的，写锁会阻塞其他的写锁和读锁。
	
- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

#####  间隙锁GAP

  当我们**用范围条件检索数据**而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给**符合范围条件的已有数据记录的索引项加锁**；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。

  值得注意的是：间隙锁只会在`Repeatable read`隔离级别下使用~

  例子：假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101

  ```sql
  Select * from  emp where empid > 100 for update;
  ```

  上面是一个范围查询，InnoDB**不仅**会对符合条件的empid值为101的记录加锁，也会对**empid大于101（这些记录并不存在）的“间隙”加锁**。

  InnoDB使用间隙锁的目的有两个：

  - 为了防止幻读
  - 满足恢复和复制的需要
    - MySQL的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读

#### 乐观锁和悲观锁
- 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。
- 悲观锁是数据库层面加锁，都会阻塞去等待锁。
#### 死锁
并发的问题就少不了死锁，在MySQL中同样会存在死锁的问题。
但一般来说MySQL通过回滚帮我们解决了不少死锁的问题了，但死锁是无法完全避免的，可以通过以下的经验参考，来尽可能少遇到死锁：
1. 以固定的顺序访问表和行。比如对两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；将两个事务的sql顺序调整为一致，也能避免死锁。
2. 大事务拆小。大事务更倾向于死锁，如果业务允许，将大事务拆小。
3. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率。
4. 降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。
5. 为表添加合理的索引。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。



---

参考

[数据库两大神器【索引和锁】](https://juejin.im/post/6844903645125820424)


