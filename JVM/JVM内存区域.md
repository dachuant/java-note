> https://snailclimb.gitee.io/javaguide/

---

# 1 运行时数据区域

​		Java虚拟机所管理的内存，以下图基于HotSpot虚拟机，JDK1.6~JDK1.8略有不同；

​		JDK1.7中，把原本放在方法区的字符串常量池移动到堆区；

​		JDK1.8中，移除方法区，用元空间代替。

<img src="https://gitee.com/dachuant/image/raw/master/picgo/20201128005422.png" alt="image-20201128005207180" style="zoom:50%;" />



<img src="https://gitee.com/dachuant/image/raw/master/picgo/20201128005443.png" alt="image-20201128005443659" style="zoom:50%;" />



<img src="https://gitee.com/dachuant/image/raw/master/picgo/20201128005504.png" alt="image-20201128005504497" style="zoom:50%;" />

## 1.1 程序计数器

​		是一块较小的内存空间，字节码解释器工作时通过改变程序计数器来来选取下一条需要执行的字节码指令，分支循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。

​		线程私有，线程切换后能恢复到正确的执行位置。

​		**程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域**



## 1.2 Java虚拟机栈 

​		1）线程私有。

​		2）每个方法在执行的同时都会创建一个栈帧，方法从调用到完成的过程，对应着栈帧在虚拟机中栈中的入栈到出栈。

![image-20210128221323663](https://gitee.com/dachuant/image/raw/master/picgo/20210128221323.png)

​		3）虚拟机对这个区域定义了2种异常：

​			a）如果虚拟机栈不允许动态扩展，线程请求的栈深度大于虚拟机允许的深度，将抛出`StackOverflowError`异常；

​			b）如果虚拟机栈允许动态扩展，扩展时无法申请到足够的内存，将抛出`OutOfMemoryError`异常。



## 1.3 本地方法栈

​		线程私有，与虚拟机栈相似。区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈 为虚拟机使用到的Native方法服务。

## 1.4 Java堆

​		线程共享，所有的对象实例以及数据都在堆上分配内存，但随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

​		Java堆细分为：新生代、老年代；再细致一点有Eden空间、From Survivor空间、To Survivor 空间。

​		从内存分配角度看，线程共享的Java堆区中可能划分为多个线程私有的`分配缓冲区（Thread Local Allocation Buffer，TLAB）	`。



## 1.5 方法区

​		线程共享，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分。但他却有一个别名`Non-Heap (非堆)`，目的是与Java堆区分开。

​		方法区无法满足内存分配需求时，将抛出`OutOfMemoryError`异常。



## 1.6 运行时常量池

​		属于方法区的一部分，Class文件除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

​		一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

​		运行期间也可能将新的常量放入池中，如String类的intern()方法

## 1.7 直接内存

​		**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**

​		JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

​		本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。